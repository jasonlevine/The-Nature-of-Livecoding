;;window and renderer setup
(sys:load "libs/external/glfw3.xtm")
(sys:load "The-Nature-of-Livecoding/vec2.xtm")

(bind-val window GLFWwindow*
  (begin
    (glfwSetErrorCallback (convert (get_native_fptr glfw_error_callback)))
    (glfw_init_and_create_interaction_window (convert width) (convert height))))

(sys:load "libs/external/nanovg.xtm")
(bind-val vg NVGcontext* (nvg_create_context))
(bind-val pixel_ratio float (glfw_get_pixel_ratio window))


;; wrappers for processing like functions and vars

;; background
(bind-func background_gray
	(lambda (gray:i8)
    (let ((grayf:float  (/ (i8tof gray) 255.)))
		  (_nvgFillColor vg (NVGcolor grayf grayf grayf 1.0)))
    (nvgBeginPath vg)
    (nvgRect vg 0. 0. width height)
    (nvgFill vg)))

(bind-func background_RGBf
  (lambda (r:float g b)
      (_nvgFillColor vg (NVGcolor r g b 1.0))
      (nvgBeginPath vg)
      (nvgRect vg 0. 0. width height)
      (nvgFill vg)))

(bind-poly background background_RGBf)
(bind-poly background background_gray)

;; fill
(bind-func fill_RGBAf
	(lambda (r:float g b a)
		(_nvgFillColor vg (NVGcolor r g b a))))    

(bind-func fill_gray
  (lambda (gray:i8)
     (let ((grayf:float  (/ (i8tof gray) 255.)))
      (_nvgFillColor vg (NVGcolor grayf grayf grayf 1.0)))))
  

(bind-poly fill fill_RGBAf)
(bind-poly fill fill_gray)


(bind-func no_fill
  (lambda ()
    (fill 0.0 0.0 0.0 0.0)))

;;stroke
(bind-func stroke_RGBAf
	(lambda (r:float g b a)
		(_nvgStrokeColor vg (NVGcolor r g b a))))

(bind-func stroke_gray
  (lambda (gray:i8)
     (let ((grayf:float  (/ (i8tof gray) 255.)))
      (_nvgStrokeColor vg (NVGcolor grayf grayf grayf 1.0))))) 

(bind-poly stroke stroke_RGBAf)
(bind-poly stroke stroke_gray)  

(bind-func no_stroke
  (lambda ()
    (stroke 0.0 0.0 0.0 0.0)))

(bind-func stroke_width
	(lambda (width:float)
		(nvgStrokeWidth vg width)))


;; circle
(bind-func circle_xy
	(lambda (x:float y radius)
		(nvgBeginPath vg)
    (nvgCircle vg x y radius)
    (nvgFill vg)
    (nvgStroke vg)))

(bind-func circle_vec
  (lambda (pos:vec radius:float)
    (nvgBeginPath vg)
    (nvgCircle vg (vec2_get_x pos) (vec2_get_y pos) radius)
    (nvgFill vg)
    (nvgStroke vg)))

(bind-poly circle circle_xy)
(bind-poly circle circle_vec)

;; rectangle
(bind-func rectangle
	(lambda (x:float y w h)
		(nvgBeginPath vg)
    (nvgRect vg x y w h)
    (nvgFill vg)
    (nvgStroke vg)))

;; line
(bind-func line
  (lambda (x1:float y1 x2 y2)
    (nvgBeginPath vg)
    (nvgMoveTo vg x1 y1)
    (nvgLineTo vg x2 y2)
    (nvgClosePath vg)
    (nvgStroke vg)))

;;--------RANDOM-------

(bind-func rand_range
  (lambda (min:float max)
    (+ (* (random) (- max min)) min)))

(bind-func rand_max
  (lambda (max:float)
    (* (random) max)))


;; --------MATH--------
(bind-func constrain
  (lambda (val:float min:float max:float)
    (cond ((< val min) min)
          ((> val max) max)
          (else val))))



;; Transformations
(bind-func translate
  (lambda (x:float y)
    (nvgTranslate vg x y)))


;; ------MOUSE------
(bind-func mouse_x
  (lambda ()
    (let ((x_ptr:double* (salloc))
          (y_ptr:double* (salloc)))
      (glfwGetCursorPos window x_ptr y_ptr)
      (convert (pref x_ptr 0) float))))

(bind-func mouse_y
  (lambda ()
    (let ((x_ptr:double* (salloc))
          (y_ptr:double* (salloc)))
      (glfwGetCursorPos window x_ptr y_ptr)
      (convert (pref y_ptr 0) float))))


;;  ------DRAW LOOP------
;; empty draw func to be reevaluated
(bind-func draw
    (lambda ()
    	(background 0.0 0.0 0.0)))

; draw loop
(bind-func nvg_draw_loop
	(let ((frame:i64 0))
  (lambda (time:i64 delta_t:double)
    ;(nvg_clear)
    (nvgBeginFrame vg (convert width) (convert height) pixel_ratio)
    (nvgResetTransform vg)
    (draw)
    (nvgEndFrame vg)
    (set! frame (+ frame 1)) 
    (glfwPollEvents)
    (glfwSwapBuffers window) 
    (let ((next_time (+ time (convert (* 44100. delta_t)))))
      (callback next_time nvg_draw_loop next_time delta_t)))))

;(bind-func get_frame:[i64,void]*
;  (lambda ()
;    (nvg_draw_loop.frame)))
;; another attempt to schemify my draw loop to allow (play) and to avoid pauses in animation when reompiling. Failed.
; (define draw
;     (lambda ()
;       (background 1.0 0.0 0.0)))

; (bind-func nvg_begin
;   (lambda ()
;     (nvgBeginFrame vg (convert width) (convert height) pixel_ratio)
;     (nvgResetTransform vg)))

; (bind-func nvg_end
;   (lambda ()
;     (nvgEndFrame vg)))

; (define nvg_draw_loop
;   (let ((frame 0))
;   (lambda (time delta_t)
;     (nvg_begin)
;     (draw)
;     (nvg_end)
;     (set! frame (+ frame 1)) 
;     (let ((next_time (+ time (* 44100. delta_t))))
;       (callback next_time nvg_draw_loop next_time delta_t)))))


;; an attempt to avoid to freeze when draw is recompiled. didn't work
; (bind-func nvg_draw_frame
;   (lambda ()
;     (nvgBeginFrame vg (convert width) (convert height) pixel_ratio)
;     (nvgResetTransform vg)
;     (draw)
;     (nvgEndFrame vg)
;     (glfwPollEvents)
;     (glfwSwapBuffers window)))

; (define nvg_draw_loop
;   (let ((frame 0))
;   (lambda (time delta_t)
;     (nvg_draw_frame)
;     (set! frame (+ frame 1)) 
;     (let ((next_time (+ time (* 44100. delta_t))))
;       (callback next_time nvg_draw_loop next_time delta_t)))))

;;start draw loop
(nvg_draw_loop (now) (/ 1. 60.))

;; to stop the draw loop, eval this version of nvg_draw_loop
;; (bind-func nvg_draw_loop
;;   (lambda (time:i64 delta_t:double)
;;     (println "nvg_draw_loop callback stopped")
;;     #f))

